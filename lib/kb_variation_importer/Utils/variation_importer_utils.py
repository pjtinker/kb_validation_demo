import os
import subprocess
import uuid
import time
import shutil

from DataFileUtil.DataFileUtilClient import DataFileUtil
from KBaseReport.KBaseReportClient import KBaseReport

class InvalidVCFError(Exception):
    def __init__(self, file_path, message):
        self.file_path = file_path
        self.message = message
    def __str__(self):
        return repr(self.message + self.file_path)

def log(message, prefix_newline=False):
    """Logging function, provides a hook to suppress or redirect log messages."""
    print(('\n' if prefix_newline else '') + '{0:.2f}'.format(time.time()) + ': ' + str(message))

#TODO: All manner of input validation checks.

class variation_importer_utils:

    def __init__(self, storage_dir):
        self.storage_dir = storage_dir

    def pretend_download_staging_file(self, vcf_path):
        print("Value passed to pretend_download: {}".format(vcf_path))
        scratch = '/kb/module/work/tmp/'
        shutil.copy('/kb/module/data/' + vcf_path, scratch + vcf_path)
        return { 'copy_file_path': scratch + vcf_path }

    def _validate_vcf(self, vcf_path):
        """
            :param vcf_path: string defining directory of VCF file
        """
        # TODO determine size of file.  May want to use HDF5 
        print('\nValidating {}'.format(vcf_path))
        try:
            f = open(vcf_path, "r")
        except Exception as e:
            print("Error opening file: {}".format(e))
            raise InvalidVCFError(vcf_path, e)
        
        line = f.readline()
        tokens = line.split('=')
        f.close()
        if(tokens[0] != "##fileformat" or int(tokens[1][4]) != 4):
            # TODO: Add messages based on incorrect VCF version or basic formatting error
            # TODO: add additional validation procedures
            print("{} format is invalid!".format(vcf_path.split('/')[-1]))
            raise InvalidVCFError(vcf_path, "{} format is invalid!".format(vcf_path.split('/')[-1]))

        vcf_version = tokens[1][4:7]
        print("Valid VCF file, version: {}".format(vcf_version))

        return vcf_version   

    def generate_vcf_stats(self, cmd_line_args, scratch_subdir_path):
        """
            :param commments go here
        """
        
        if(not os.path.isdir(self.storage_dir)):
            print("\nCreating storage directory {}...".format(self.storage_dir))
            try:
                os.mkdir(self.storage_dir)
            except Exception as e:
                raise ValueError(e)

        print("Results will be written to {}".format(self.storage_dir))
        try:
            self._validate_vcf(scratch_subdir_path)
        except InvalidVCFError as ive:
            raise ValueError(ive.message)

        ## TODO: Validate user supplied params and build PLINK command
        plink_cmd = ["plink"]
        plink_cmd.append('--vcf')
        plink_cmd.append(scratch_subdir_path)
        if(cmd_line_args is not None):
            cmds = cmd_line_args.split(';')
            for cmd in cmds:
                plink_cmd.append(cmd)
        # plink_cmd.append('--recode12')
        # plink_cmd.append('transpose')
        # plink_cmd.append('--output-missing-genotype')
        # plink_cmd.append("0")
        plink_cmd.append('--freq')
        plink_cmd.append('--out')
        plink_cmd.append('frequencies')

        print("PLINK arguments: {}".format(plink_cmd))

        plink_output = []
        p = subprocess.Popen(plink_cmd, \
                            cwd = self.storage_dir, \
                            stdout = subprocess.PIPE, \
                            stderr = subprocess.STDOUT, \
                            shell = False)
        while True:
            line = p.stdout.readline()
            if not line: break
            #print(line.replace('\n', ''))
            tokens = line.split(':')
            if(tokens[0] == 'Error'):
                raise ValueError('PLINK 1.9 error: ' + line)
            elif(tokens[0] == 'Warning'):
                plink_output.append(line)
                print(line)
            elif(tokens[0] == 'Note'):
                plink_output.append(line)
                print(line)
        
        p.stdout.close()
        p.wait()

        if p.returncode != 0:
            raise ValueError("Error running PLINK, return code: " + str(p.returncode))
        # TODO: correct for the user supplied output file name.  Should I allow them to name?
        # TODO: Check for whatever file type has been generated by user commands.
        if not os.path.isfile(self.storage_dir+"frequencies.frq"):
            raise ValueError("PLINK failed to create frequency file {} frequencies.frq".format(self.storage_dir))
        
        return